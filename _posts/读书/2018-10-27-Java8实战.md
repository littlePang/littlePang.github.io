---
layout: post
title: Java8实战
category: 技术
tags: Java8
keywords:
description:
---

# 基础知识

java8改进：

* lambda 表达式
* stream 流
* 接口默认方法 (为了把stream()等方法加在 Collection 上，增加了接口默认方法的方式来实现)

第二章：
* 行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。
* 行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。
* 传递代码，就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java 8之前可以用匿名类来减少。
* Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理


常用函数式接口
* java.util.function.Predicate<T>   包含 negate、and和or 用来创建更加复杂的谓词
* java.util.function.Consumer<T>
* java.util.function.Function<T, R>   andThen和compose两个默认方法 用于function组合

为避免简单对象的拆箱和装箱造成的性能损耗，jdk提供了 IntPredicate,LongPredicate，IntToDoubleFunction, IntToLongFunction等接口

lambda 对局部变量引用的限制：必须为final或者事实final(即使没有声明为final,但是并没有修改过它的值)的。
第一，实例变量和局部变量背后的实现有一 个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局 部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线 程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它 的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了 这个限制。


对构造器有多个参数的类使用构造函数引用

            static class Color {
                public Color(int a, int b, int c) {
                }
              }

            public interface TriFunction<T, U, V, R>{
                     R apply(T t, U u, V v);
            }

            TriFunction<Integer, Integer, Integer, Color> colorFactory = Color::new;


@FunctionalInterface 这个标注用于表示该接口会设计成 一个函数式接口,不是必需的，但对于为此设计的接口而言，使用它是比较好的做法。它就像是@Override 标注表示方法被重写了。

Comparator.comparing 比较器链


# 函数式数据处理

流到底是什么呢?简短的定义就是“从支持数据处理操作的源生成的元素序列”

流就 像是一个延迟创建的集合:只有在消费者要求的时候才会计算值(用管理学的话说这就是需求驱 动，甚至是实时制造)。与此相反，集合则是急切创建的(供应商驱动:先把仓库装满，再开始卖，就像那些昙花一现的圣诞新玩意儿一样)。

请注意，流和迭代器类似，流只能遍历一次


流操作：
* 中间操作，filter，map等
* 终端操作，forEach，count，collect等方法


使用流：
* 筛选、切片和匹配 （filter，limit， skip，map）
* 查找、匹配和归约 (allMatch、anyMatch、noneMatch、findFirst和findAny, reduce)
* 使用数值范围等数值流  从多个源创建流
* 无限流


流不仅可以从集合创建，也可从值、数组、文件以及iterate与generate等特定方法创建。


用流收集数据:
* 用Collectors类创建和使用收集器
* 将数据流归约为一个值, Collectors.averagingInt,Collectors.counting() ,Collectors.joining()等
* 汇总:归约的特殊情况  Collectors.joining()等
* 数据分组和分区 Collectors.groupingBy 支持多级分类， partitioningBy 分区（得到的分组Map的键类型是Boolean）   
* 开发自己的自定义收集器,使用 java.util.stream.Collector 自定义收集器


并行数据处理与性能：
* 用并行流并行处理数据
* 并行流的性能分析
* 分支/合并框架
* 使用Spliterator分割流
