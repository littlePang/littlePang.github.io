---
layout: post
title: 十万个为什么
category: 学习
tags: study
keywords:
description:
---


## g1 收集器的 fullGC 和youngGC (都只是分区,而没有新生代和老年代的区别的话, 那还分这两种GC方式么?)

分, g1 收集器,对内存虽然不像CMS一样将内存分为 新生代,老年代,和永久代, 而是将内存分为多个大小相等的区域,但是也会将不同的内存区域划分为不同代.
以下图片出处:[传送门](http://blog.csdn.net/renfufei/article/details/41897113)

![](/assets/picture/2016-08-11_g1_memory_layout.png)


## 软引用 引发的youngGC 和 fullGC 谁更先发生?
必然是 youngGC 回收软引用指向的对象先发生, fullGC只在youngGC无法满足内存需求时,才会发生.

## MQ中pull和push的差别
[表格出处](http://www.blogjava.net/killme2008/archive/2011/04/30/349303.html)


| | push模式 | pull模式|
 |----|---- |----|
| 描述 | 服务端主动发送数据给客户端 | 客户端主动从服务端拉去数据,通常客户端会定时拉取|
|  实时性 | 较好,收到数据后可立即发送给客户端 | 一般,取决于pull的间隔时间|
|  服务端状态| 需要保存push状态,哪些客户端以及发送成功,哪些发送失败| 服务端无状态(不用保存消息拉取状态什么的?那如何保证消息一定被consumer消费了?)|
|  客户端状态| 无需额外保存状态 | 需保存当前拉取的信息状态,以便在故障或者重启的时候恢复|
|  状态保存|集中式,集中在服务端|分布式,分散在各个客户端|
|  负载均衡|服务端统一处理和控制|客户端之间做分配, 需要协调机制,如使用zookeeper|
|  其他|服务端需要做流量控制,无法最大话客户端的处理能力.其次,客户端故障的情况下,无效的push对服务端有一定负载(这个可以通过health check来做,若consumer已挂,则不再push)|客户端的请求可能有很多无效或者没有数据可供传输,浪费带宽和服务器处理能力
|  确定方案|服务端状态存储是个难点,可将这些状态转移到DB或者key-value存储,来减轻server压力| 针对实时性的问题,可以将push加入进来,push小鼠据的通知信息,让客户端再开主动pull(服务端告诉客户端想在有多少消息,consumer根据自己的能力主动pull消息).针对无效请求的问题,可以设置逐渐延长间隔时间的策略,以及合理设计协议尽量缩晓请求数据包来节省带宽.|

 一些MQ的对比博文:

 [http://blog.csdn.net/sunxinhere/article/details/7968886](http://blog.csdn.net/sunxinhere/article/details/7968886)

 [http://www.fattiger.com.cn/2016/03/14/mq-compare/](http://www.fattiger.com.cn/2016/03/14/mq-compare/)

 [http://www.th7.cn/Program/Ruby/201604/796433.shtml](http://www.th7.cn/Program/Ruby/201604/796433.shtml)

## 匿名类的一个使用特性
由于匿名类的实例,在刚刚new出来的时候,编辑器(javac)是知道它的实际类型的,所以匿名类增加了基类没有的方法的情况下,也是能够正常调用的.例如:

                    // 匿名类中增加了基类的没有的方法,依然可以在刚new出来的时候调用.
                    new Object(){
                          boolean foo() {
                              System.out.println("foo");
                              return false;
                          }
                      }.foo()
