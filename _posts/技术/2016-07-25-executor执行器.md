---
layout: post
title: Executor执行器
category: 学习
tags: javaConcurrent
keywords:
description:
---

## Collection集合框架体系

![](/assets/picture/2016-07-25_executor.png)

`Executor`用来代替显示创造线程(例如:`new Thread(new(RunnableTask())).start()`),接口并不要求所有实现都是异步的.也可想下面这样同步执行:

        class DirectExecutor implements Executor {
              public void execute(Runnable r) {
                  r.run();
              }
        }


`java.util.concurrent.Executors`提供各种执行器的工厂方法.

## 杂记

### ExecutorService

* 可产生`Future`用来跟踪异步任务处理进度.
* 可通过`shutdown()`(拒绝新任务,已提交的任务会执行完)或者`shutdownNow()`(立即关闭,已提交的任务会中断.)

![](/assets/picture/2016-07-25_executorService_method.png)

### AbstractExecutorService
`invokeAny(Collection<? extends Callable<T>> tasks)` 和 `invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)` 底层都是调用`doInvokeAny(Collection<? extends Callable<T>> tasks, boolean timed, long nanos)` 方法执行的.

源码:


                 // 记录所有已提交执行的任务,方便最后关闭
                List<Future<T>> futures= new ArrayList<Future<T>>(ntasks);

                // 任务执行结果获取器,若提交的任务完成,则会被放入一个队列中.
                ExecutorCompletionService<T> ecs =
                    new ExecutorCompletionService<T>(this);

                // 为了更有效率,尤其是在有并发限制的executor执行器上.在提交更多任务前,检查前一个提交的任务是否完成.
                // This interleaving plus the exception mechanics account for messiness of main loop. (异常叠加造成主循环混乱?)

                try {
                    // 如果没有获取到任何结果,则抛出最后一个异常
                    ExecutionException ee = null;

                    // 记录上一个任务执行结束的时间点
                    long lastTime = timed ? System.nanoTime() : 0;

                    Iterator<? extends Callable<T>> it = tasks.iterator();

                    // 将第一个任务提交并保存.
                    futures.add(ecs.submit(it.next()));
                    --ntasks;
                    int active = 1;// 记录正在执行的任务个数

                    for (;;) {
                        // 获取前面已提交任务的执行结果,若无结果 poll() 方法会立即返回null
                        Future<T> f = ecs.poll();
                        if (f == null) {
                           // 若前面的提交的任务都无执行结果
                            if (ntasks > 0) {
                               // 若还有未提交的任务,则提交一个任务.
                                --ntasks;
                                futures.add(ecs.submit(it.next()));
                                ++active;
                            }
                            else if (active == 0) // 若已经没有正在执行的任务.则跳出循环.
                                break;
                            else if (timed) {
                               // 若有超时限制, 则在时限内去获取最快完成任务的结果
                                f = ecs.poll(nanos, TimeUnit.NANOSECONDS);

                                //若无结果,则任务执行超时
                                if (f == null)
                                    throw new TimeoutException();

                                // 记录最新完成的任务的时间点,并从时限中减去任务完成花费的时间
                                long now = System.nanoTime();
                                nanos -= now - lastTime;
                                lastTime = now;
                            }
                            else
                                f = ecs.take(); // 若无超时时限,则一直阻塞,直到有任务执行完成.
                        }
                        if (f != null) {
                          // 获取到结果,则有任务执行完成.执行中任务个数减一
                            --active;

                            // 获取任务执行结果失败, 则记录异常.所有任务都执行完成,仍无法获取结果时,抛出最后一个异常
                            try {
                                return f.get();
                            } catch (ExecutionException eex) {
                                ee = eex;
                            } catch (RuntimeException rex) {
                                ee = new ExecutionException(rex);
                            }
                        }
                    }

                    // 所有任务都执行完成,仍无法获取结果时,抛出最后一个异常
                    if (ee == null)
                        ee = new ExecutionException();
                    throw ee;

                } finally {
                  // 方法返回前,关闭所有提交的任务(若有任务完成并成功返回结果.可能还有其他任务正在执行)
                    for (Future<T> f : futures)
                        f.cancel(true);
                }
