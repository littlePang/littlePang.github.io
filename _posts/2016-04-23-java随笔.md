---
layout: post
title: JVM随笔
category: 杂项
tags: JVM
keywords:
description:
---

### 内存信息dump

        # 导出整个JVM 中内存信息
        jmap -dump:format=b,file=文件名 [pid]

        # 查看JVM堆中对象详细占用情况
        jmap -histo [pid]

        # dump内容分析，默认端口 7000
        jhat -J-Xmx1024M [file]

### 查看JVM默认启动参数

      java -XX:+PrintFlagsFinal -version

### 设置方法区（永久代）大小

      -XX:PermSize=10M -XX:MaxPermSize=10M

在JDK1.8之后使用 -XX:MaxMetaspaceSize=128m  设置元空间大小（JVM参数PermSize 和 MaxPermSize会被忽略，当前在启动时会有警告信息）

## 设置GC日志输出

        -XX:+PrintGC  简略信息输出
        -XX:+PrintGCDetails    详细信息输出
        -XX:+PrintGCTimeStamps   gc时间打印
        -XX:+PrintGCApplicationStoppedTime   停顿时间
        -XX:+PrintGCApplicationConcurrentTime 打印每次垃圾回收前,程序未中断的执行时间
        -XX:+PrintHeapAtGC	打印GC前后的详细堆栈信息
        -Xloggc:filename	把相关日志信息记录到文件以便分析.
        -XX:+PrintClassHistogram 垃圾回收前打印类信息柱状图
        -XX:+PrintTenuringDistribution	  查看每次minor GC后新的存活周期的阈值
        -XX:+PrintTLAB   查看TLAB空间的使用情况



## JDK8 默认堆大小
初始化 128M，最大2G,且默认使用 Parallel 垃圾收集器(标记整理)

 > uintx InitialHeapSize                          := 134217728
 > uintx MaxHeapSize                              := 2147483648
 > bool UseParallelGC                            := true
 > bool UseParallelOldGC                          = true

JDK8元空间说明：

http://caoyaojun1988-163-com.iteye.com/blog/1969853

http://www.infoq.com/cn/articles/Java-PERMGEN-Removed

http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html

# G1垃圾收集器GC日志说明

[https://blogs.oracle.com/poonam/understanding-g1-gc-logs](https://blogs.oracle.com/poonam/understanding-g1-gc-logs)

# arraylist get(负数) 抛出 IndexOutOfBoundsException 没有栈异常信息

# long 转 int 可能为负数

3421665166L 强转为 int 输出为 -873302130


# fullGC 过多 导致 用户线程暂停，zk心跳异常

日志打了一半，后续既没有info日志，也没有异常日志


# jar 包 release 版本以前可以覆盖，导致本地仓库的jar包是老版本，使用rources 包是最新的，查看包的源码是没有问题的，
但是运行一段时间后，执行到调用该方法的地方，则报错，无此方法。


# JSON 相关框架性能比较

整体来说，小对象的序列化和反序列化 ，gson表现最好，大对象的序列化和反序列化, jackson 是更好的选择，fastjson 虽然也在速度上也不错，但其功能完备性相对较差

> http://www.cnblogs.com/java-class/p/6653735.html
> http://www.bijishequ.com/detail/373398

fastjson 普及性的问题：
> https://www.zhihu.com/question/44199956


# spring事务方法内部调用生效

使用 AopContext.currentProxy() 直接获取代理对象，执行方法调用

并在配置中指定

        <property name="exposeProxy">  
                    <value>true</value>  
                </property


# 多个事务管理器，默认使用的事务管理器

多个事务管理器，默认使用的事务管理器，根据加载顺序决定，第一个加载到的事务管理器，作为默认事务管理器


# @ComponentScan 注解 默认包扫描

如果 basePackages 未配置，则默认从使用这个注解的类所在的包开始扫描



# 下面的调用，在找不到 NotSupportedException (此类由运行时加载，运行环境中可能找不到) 时会抛出异常：

        public final class Test {

          private Test() throws NotSupportedException {
            throw new NotSupportedException("不可实例化");
          }

          public static void main(String[] args) {
            System.out.println(11);
          }

# Bean copy 性能比较

Apache Beanutils 性能最差
cglib性能最好
spring 的 BeanUtils 居中

# JDK7 的 Try-with-resources

下面代码可以自动关闭实现了java.lang.AutoCloseable或java.io.Closeable的对象资源

        try (BufferedReader br = new BufferedReader(new FileReader(path))) {  
              return br.readLine();  
           }  

# 桥接方法（bridge method）

https://blog.csdn.net/mhmyqn/article/details/47342577
